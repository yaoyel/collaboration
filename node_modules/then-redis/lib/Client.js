'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _url = require('url');

var _redisCommands = require('redis-commands');

var _redisCommands2 = _interopRequireDefault(_redisCommands);

var _redis = require('redis');

var _redis2 = _interopRequireDefault(_redis);

var _RedisUtils = require('./RedisUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ClientProperties = [
// redis properties, forwarded read-only.
'connection_id', 'connected', 'ready', 'connections', 'options', 'pub_sub_mode', 'selected_db'];

var ConnectionEvents = ['ready', 'connect', 'reconnecting', 'error', 'end'];

var MonitorEvents = ['monitor'];

var PubSubEvents = ['message', 'pmessage', 'subscribe', 'psubscribe', 'unsubscribe', 'punsubscribe'];

var AllEvents = [].concat(ConnectionEvents, MonitorEvents, PubSubEvents);

var DefaultPort = 6379;
var DefaultHost = '127.0.0.1';

var DefaultConfig = {
  port: DefaultPort,
  host: DefaultHost
};

/**
 * A Redis client that returns promises for all operations.
 */

var Client = function (_EventEmitter) {
  _inherits(Client, _EventEmitter);

  /**
   * Supported options are:
   *
   * - port             The TCP port to use (defaults to 6379)
   * - host             The hostname of the Redis host (defaults to 127.0.0.1)
   * - database         The database # to use (defaults to 0)
   * - password         The password to use for AUTH
   * - returnBuffers    True to return buffers (defaults to false)
   */

  function Client(options) {
    _classCallCheck(this, Client);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Client).call(this));

    var config = options || process.env.REDIS_URL || DefaultConfig;

    if (typeof config === 'string') {
      var url = (0, _url.parse)(config);

      config = {
        port: url.port,
        host: url.hostname
      };

      if (url.auth) {
        var split = url.auth.split(':');

        if (split[0] && !isNaN(split[0])) config.database = split[0];

        if (split[1]) config.password = split[1];
      }
    }

    _this.port = parseInt(config.port, 10) || 6379;
    _this.host = config.host || '127.0.0.1';

    if (config.password) config.auth_pass = config.password;

    if (config.returnBuffers) config.return_buffers = true;

    var redisClient = _redis2.default.createClient(_this.port, _this.host, config);

    AllEvents.forEach(function (eventName) {
      redisClient.on(eventName, _this.emit.bind(_this, eventName));
    }, _this);

    _this._redisClient = redisClient;

    if (config.database) _this.select(config.database);
    return _this;
  }

  _createClass(Client, [{
    key: 'unref',
    value: function unref() {
      this._redisClient.unref();
    }
  }, {
    key: 'send',
    value: function send(command) {
      var _this2 = this;

      var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

      return new Promise(function (resolve, reject) {
        _this2._redisClient.send_command(command, args, function (error, value) {
          if (error) {
            reject(error);
          } else {
            resolve(value);
          }
        });
      });
    }

    // Update the selected_db property of the client on SELECT.

  }, {
    key: 'select',
    value: function select(db) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        // Need to use this so selected_db updates properly.
        _this3._redisClient.select(db, function (error, value) {
          if (error) {
            reject(error);
          } else {
            resolve(value);
          }
        });
      });
    }

    // Parse the result of INFO.

  }, {
    key: 'info',
    value: function info() {
      return this.send('info').then(_RedisUtils.parseInfo);
    }

    // Optionally accept an array as the first argument to LPUSH after the key.

  }, {
    key: 'lpush',
    value: function lpush(key) {
      for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      var args = [key].concat(Array.isArray(values[0]) ? values[0] : values);
      return this.send('lpush', args);
    }

    // Optionally accept an array as the first argument to RPUSH after the key.

  }, {
    key: 'rpush',
    value: function rpush(key) {
      for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        values[_key2 - 1] = arguments[_key2];
      }

      var args = [key].concat(Array.isArray(values[0]) ? values[0] : values);
      return this.send('rpush', args);
    }

    // Optionally accept an array as the only argument to DEL.

  }, {
    key: 'del',
    value: function del() {
      for (var _len3 = arguments.length, keys = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        keys[_key3] = arguments[_key3];
      }

      var args = Array.isArray(keys[0]) ? keys[0] : keys;
      return this.send('del', args);
    }

    // Optionally accept an array as the only argument to MGET.

  }, {
    key: 'mget',
    value: function mget() {
      for (var _len4 = arguments.length, keys = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        keys[_key4] = arguments[_key4];
      }

      var args = Array.isArray(keys[0]) ? keys[0] : keys;
      return this.send('mget', args);
    }

    // Optionally accept a hash as the only argument to MSET.

  }, {
    key: 'mset',
    value: function mset() {
      for (var _len5 = arguments.length, keysAndValues = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        keysAndValues[_key5] = arguments[_key5];
      }

      var args = _typeof(keysAndValues[0]) === 'object' ? (0, _RedisUtils.appendHashToArray)(keysAndValues[0], []) : keysAndValues;

      return this.send('mset', args);
    }

    // Optionally accept a hash as the only argument to MSETNX.

  }, {
    key: 'msetnx',
    value: function msetnx() {
      for (var _len6 = arguments.length, keysAndValues = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        keysAndValues[_key6] = arguments[_key6];
      }

      var args = _typeof(keysAndValues[0]) === 'object' ? (0, _RedisUtils.appendHashToArray)(keysAndValues[0], []) : keysAndValues;

      return this.send('msetnx', args);
    }

    // Optionally accept a hash as the first argument to HMSET after the key.

  }, {
    key: 'hmset',
    value: function hmset(key) {
      for (var _len7 = arguments.length, keysAndValues = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
        keysAndValues[_key7 - 1] = arguments[_key7];
      }

      var args = _typeof(keysAndValues[0]) === 'object' ? (0, _RedisUtils.appendHashToArray)(keysAndValues[0], [key]) : [key].concat(keysAndValues);

      return this.send('hmset', args);
    }
  }]);

  return Client;
}(_events.EventEmitter);

ClientProperties.forEach(function (propertyName) {
  Object.defineProperty(Client.prototype, propertyName, {
    configurable: true,
    enumerable: false,
    get: function get() {
      return this._redisClient[propertyName];
    }
  });
});

_redisCommands2.default.list.forEach(function (command) {
  // Some commands have spaces in them, like CONFIG SET.
  var methodName = command.split(' ')[0];

  if (methodName in Client.prototype) return;

  Object.defineProperty(Client.prototype, methodName, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: function value() {
      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      return this.send(command, args);
    }
  });
});

module.exports = Client;